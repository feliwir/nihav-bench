From a9f78a71f2bbc7a26c9d9dffac4b7d7ba6a669f1 Mon Sep 17 00:00:00 2001
From: Stephan Vedder <vedder@mbits.info>
Date: Thu, 18 Nov 2021 15:38:10 +0100
Subject: [PATCH] optimize loop filter

---
 nihav-duck/src/codecs/vp5.rs      |  4 +-
 nihav-duck/src/codecs/vp56.rs     | 22 +++++-----
 nihav-duck/src/codecs/vp6.rs      |  6 +--
 nihav-duck/src/codecs/vpcommon.rs | 71 ++++++++++++++++++-------------
 4 files changed, 59 insertions(+), 44 deletions(-)

diff --git a/nihav-duck/src/codecs/vp5.rs b/nihav-duck/src/codecs/vp5.rs
index 48fda2d..948ed99 100644
--- a/nihav-duck/src/codecs/vp5.rs
+++ b/nihav-duck/src/codecs/vp5.rs
@@ -218,7 +218,7 @@ impl VP56Parser for VP5BR {
     fn decode_block_huff(&self, _br: &mut BitReader, _coeffs: &mut [i16; 64], _vp6model: &VP6Models, _model: &VP6HuffModels, _fstate: &mut FrameState) -> DecoderResult<()> {
         unreachable!();
     }
-    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_str: i16) {
+    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_tab: &[i16; 256]) {
         let (sx, sy, mx, my) = if (plane != 1) && (plane != 2) {
                 (mv.x >> 1, mv.y >> 1, mv.x & 1, mv.y & 1)
             } else {
@@ -230,7 +230,7 @@ impl VP56Parser for VP5BR {
             } else {
                 mode1
             };
-        vp_copy_block(dst, src, plane, x, y, sx, sy, 0, 1, loop_str,
+        vp_copy_block_tab(dst, src, plane, x, y, sx, sy, 0, 1, loop_tab,
                       mode, VP3_INTERP_FUNCS, mc_buf);
     }
 }
diff --git a/nihav-duck/src/codecs/vp56.rs b/nihav-duck/src/codecs/vp56.rs
index 01e8171..a84ca66 100644
--- a/nihav-duck/src/codecs/vp56.rs
+++ b/nihav-duck/src/codecs/vp56.rs
@@ -249,7 +249,7 @@ pub trait VP56Parser {
     fn decode_coeff_models(&self, bc: &mut BoolCoder, models: &mut VP56Models, is_intra: bool) -> DecoderResult<()>;
     fn decode_block(&self, bc: &mut BoolCoder, coeffs: &mut [i16; 64], model: &VP56CoeffModel, vp6model: &VP6Models, fstate: &mut FrameState) -> DecoderResult<()>;
     fn decode_block_huff(&self, br: &mut BitReader, coeffs: &mut [i16; 64], vp6model: &VP6Models, model: &VP6HuffModels, fstate: &mut FrameState) -> DecoderResult<()>;
-    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_thr: i16);
+    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_tab: &[i16; 256]);
 }
 
 enum CoeffReader<'a> {
@@ -357,6 +357,7 @@ pub struct VP56Decoder {
     last_mbt:   VPMBType,
 
     loop_thr:   i16,
+    loop_tab:   [i16; 256],
     ilace_prob: u8,
     ilace_mb:   bool,
 
@@ -440,6 +441,7 @@ impl VP56Decoder {
             last_mbt:   VPMBType::InterNoMV,
 
             loop_thr:   0,
+            loop_tab:   [0; 256],
             ilace_prob: 0,
             ilace_mb:   false,
 
@@ -974,15 +976,15 @@ impl VP56Decoder {
                 self.shuf.get_golden().unwrap()
             };
 
-        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 0, y + 0, mv, self.loop_thr);
-        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 8, y + 0, mv, self.loop_thr);
-        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 0, y + 8, mv, self.loop_thr);
-        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 8, y + 8, mv, self.loop_thr);
+        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 0, y + 0, mv, &self.loop_tab);
+        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 8, y + 0, mv, &self.loop_tab);
+        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 0, y + 8, mv, &self.loop_tab);
+        br.mc_block(frm, self.mc_buf.clone(), src.clone(), plane, x + 8, y + 8, mv, &self.loop_tab);
         if !alpha {
             let x = self.fstate.mb_x * 8;
             let y = self.fstate.mb_y * 8;
-            br.mc_block(frm, self.mc_buf.clone(), src.clone(), 1, x, y, mv, self.loop_thr);
-            br.mc_block(frm, self.mc_buf.clone(), src,         2, x, y, mv, self.loop_thr);
+            br.mc_block(frm, self.mc_buf.clone(), src.clone(), 1, x, y, mv, &self.loop_tab);
+            br.mc_block(frm, self.mc_buf.clone(), src,         2, x, y, mv, &self.loop_tab);
         }
     }
     fn do_fourmv(&mut self, br: &dyn VP56Parser, frm: &mut NASimpleVideoFrame<u8>, mvs: &[MV; 4], alpha: bool) {
@@ -993,15 +995,15 @@ impl VP56Decoder {
         for blk_no in 0..4 {
             br.mc_block(frm, self.mc_buf.clone(), src.clone(),
                         plane, x + (blk_no & 1) * 8, y + (blk_no & 2) * 4,
-                        mvs[blk_no], self.loop_thr);
+                        mvs[blk_no], &self.loop_tab);
         }
         if !alpha {
             let x = self.fstate.mb_x * 8;
             let y = self.fstate.mb_y * 8;
             let sum = mvs[0] + mvs[1] + mvs[2] + mvs[3];
             let mv = MV { x: sum.x / 4, y: sum.y / 4 };
-            br.mc_block(frm, self.mc_buf.clone(), src.clone(), 1, x, y, mv, self.loop_thr);
-            br.mc_block(frm, self.mc_buf.clone(), src,         2, x, y, mv, self.loop_thr);
+            br.mc_block(frm, self.mc_buf.clone(), src.clone(), 1, x, y, mv, &self.loop_tab);
+            br.mc_block(frm, self.mc_buf.clone(), src,         2, x, y, mv, &self.loop_tab);
         }
     }
     fn predict_dc(&mut self, mb_type: VPMBType, _mb_pos: usize, blk_no: usize, _alpha: bool) {
diff --git a/nihav-duck/src/codecs/vp6.rs b/nihav-duck/src/codecs/vp6.rs
index d968454..e8a570a 100644
--- a/nihav-duck/src/codecs/vp6.rs
+++ b/nihav-duck/src/codecs/vp6.rs
@@ -302,7 +302,7 @@ impl VP56Parser for VP6BR {
 
         Ok(())
     }
-    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mut mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_str: i16) {
+    fn mc_block(&self, dst: &mut NASimpleVideoFrame<u8>, mut mc_buf: NAVideoBufferRef<u8>, src: NAVideoBufferRef<u8>, plane: usize, x: usize, y: usize, mv: MV, loop_tab: &[i16;256]) {
         let is_luma = (plane != 1) && (plane != 2);
         let (sx, sy, mx, my, msx, msy) = if is_luma {
                 (mv.x >> 2, mv.y >> 2, (mv.x & 3) << 1, (mv.y & 3) << 1, mv.x / 4, mv.y / 4)
@@ -314,12 +314,12 @@ impl VP56Parser for VP6BR {
         if (msx & 7) != 0 {
             let foff = (8 - (sx & 7)) as usize;
             let off = 2 + foff;
-            vp31_loop_filter(tmp_blk, off, 1, 16, 12, loop_str);
+            vp31_loop_filter_tab(tmp_blk, off, 1, 16, 12, loop_tab);
         }
         if (msy & 7) != 0 {
             let foff = (8 - (sy & 7)) as usize;
             let off = (2 + foff) * 16;
-            vp31_loop_filter(tmp_blk, off, 16, 1, 12, loop_str);
+            vp31_loop_filter_tab(tmp_blk, off, 16, 1, 12, loop_tab);
         }
         let copy_mode = (mx == 0) && (my == 0);
         let mut bicubic = !copy_mode && is_luma && self.bicubic;
diff --git a/nihav-duck/src/codecs/vpcommon.rs b/nihav-duck/src/codecs/vpcommon.rs
index 22d2044..3103ccb 100644
--- a/nihav-duck/src/codecs/vpcommon.rs
+++ b/nihav-duck/src/codecs/vpcommon.rs
@@ -354,44 +354,57 @@ pub fn vp_add_block_dc(coeffs: &mut [i16; 64], bx: usize, by: usize, plane: usiz
     }
 }
 
-#[inline]
 pub fn vp31_loop_filter(data: &mut [u8], mut off: usize, step: usize, stride: usize,
                         len: usize, loop_str: i16) {
-    
-    assert!(len>=8);
-    assert!(step>=1);
-    assert!(stride>=1);
-    assert!(off >= step * 2);
+    let mut loop_tab : [i16; 256] = [0;256];
+    calc_loop_tab(loop_str, &mut loop_tab);
+    vp31_loop_filter_tab(data, off, step, stride, len, &loop_tab);
+}
+
+fn calc_loop_tab(loop_str: i16, tab: &mut[i16; 256]) {
+    for diff in -128..128_i16 {
+     tab[(diff + 128) as usize] = if diff.abs() >= 2 * loop_str {
+         0
+       } else if diff.abs() >= loop_str {
+         if diff < 0 {
+           -diff - 2 * loop_str
+         } else {
+           -diff + 2 * loop_str
+         }
+       } else {
+         diff
+       } as i16;
+    }
+  }
 
+#[inline]
+pub fn vp31_loop_filter_tab(data: &mut [u8], mut off: usize, step: usize, stride: usize, len: usize, loop_tab: &[i16; 256]) {
     for _ in 0..len {
-        assert!(off + step < data.len());
-        
-        let a = i16::from(data[off - step * 2]);
-        let b = i16::from(data[off - step]);
-        let c = i16::from(data[off]);
-        let d = i16::from(data[off + step]);
-        let mut diff = ((a - d) + 3 * (c - b) + 4) >> 3;
-        if diff.abs() >= 2 * loop_str {
-            diff = 0;
-        } else if diff.abs() >= loop_str {
-            if diff < 0 {
-                diff = -diff - 2 * loop_str;
-            } else {
-                diff = -diff + 2 * loop_str;
-            }
-        }
-        if diff != 0 {
-            data[off - step] = (b + diff) as u8;
-            data[off]        = (c - diff) as u8;
-        }
+        let a = i16::from(data[(off - step * 2) as usize]);
+        let b = i16::from(data[(off - step) as usize]);
+        let c = i16::from(data[off as usize]);
+        let d = i16::from(data[(off + step) as usize]);
+        let diff = loop_tab[(128 + (((a - d) + 3 * (c - b) + 4) >> 3)) as u8 as usize] as i16;
+        data[(off - step) as usize] = (b + diff).max(0) as u8;
+        data[off as usize]        = (c - diff).max(0) as u8;
 
         off += stride;
     }
 }
 
 pub fn vp_copy_block(dst: &mut NASimpleVideoFrame<u8>, src: NAVideoBufferRef<u8>, comp: usize,
+    dx: usize, dy: usize, mv_x: i16, mv_y: i16,
+    preborder: usize, postborder: usize, loop_thr: i16,
+    mode: usize, interp: &[BlkInterpFunc], mut mc_buf: NAVideoBufferRef<u8>)
+{
+    let mut loop_tab : [i16; 256] = [0;256];
+    calc_loop_tab(loop_thr, &mut loop_tab);
+    vp_copy_block_tab(dst, src, comp, dx, dy, mv_x, mv_y, preborder, postborder, &loop_tab, mode, interp, mc_buf);
+}
+
+pub fn vp_copy_block_tab(dst: &mut NASimpleVideoFrame<u8>, src: NAVideoBufferRef<u8>, comp: usize,
                      dx: usize, dy: usize, mv_x: i16, mv_y: i16,
-                     preborder: usize, postborder: usize, loop_str: i16,
+                     preborder: usize, postborder: usize, loop_tab: &[i16; 256],
                      mode: usize, interp: &[BlkInterpFunc], mut mc_buf: NAVideoBufferRef<u8>)
 {
     let sx = (dx as isize) + (mv_x as isize);
@@ -413,12 +426,12 @@ pub fn vp_copy_block(dst: &mut NASimpleVideoFrame<u8>, src: NAVideoBufferRef<u8>
         if (sx & 7) != 0 {
             let foff = (8 - (sx & 7)) as usize;
             let off = pre + foff + tmp_buf.offset[comp];
-            vp31_loop_filter(tmp_buf.data, off, 1, tmp_buf.stride[comp], bsize, loop_str);
+            vp31_loop_filter_tab(tmp_buf.data, off, 1, tmp_buf.stride[comp], bsize, loop_tab);
         }
         if (sy & 7) != 0 {
             let foff = (8 - (sy & 7)) as usize;
             let off = (pre + foff) * tmp_buf.stride[comp] + tmp_buf.offset[comp];
-            vp31_loop_filter(tmp_buf.data, off, tmp_buf.stride[comp], 1, bsize, loop_str);
+            vp31_loop_filter_tab(tmp_buf.data, off, tmp_buf.stride[comp], 1, bsize, loop_tab);
         }
     }
     let dxoff = (pre as i16) - (dx as i16);
-- 
2.30.2

